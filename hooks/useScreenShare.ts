import { useState, useRef, useEffect, useCallback } from "react"
import { useToast } from "@/components/ui/use-toast"

type ScreenShareState = 
  | 'idle' 
  | 'sharing' 
  | 'captured' 
  | 'analyzing' 
  | 'completed' 
  | 'error'

interface UseScreenShareProps {
  onStream?: (stream: MediaStream) => void
  onAnalysis?: (analysis: string) => void
  autoAnalyze?: boolean
}

export function useScreenShare({ 
  onStream, 
  onAnalysis, 
  autoAnalyze = false 
}: UseScreenShareProps = {}) {
  const { toast } = useToast()
  const [state, setState] = useState<ScreenShareState>('idle')
  const [stream, setStream] = useState<MediaStream | null>(null)
  const [capturedImage, setCapturedImage] = useState<string | null>(null)
  const [analysis, setAnalysis] = useState<string | null>(null)
  const [isAutoAnalyzing, setIsAutoAnalyzing] = useState(autoAnalyze)
  const [error, setError] = useState<string | null>(null)
  
  const videoRef = useRef<HTMLVideoElement>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const analysisInterval = useRef<NodeJS.Timeout | null>(null)

  // Handle stream cleanup
  useEffect(() => {
    return () => {
      stopScreenShare()
    }
  }, [])

  // Start screen sharing
  const startScreenShare = useCallback(async () => {
    try {
      setState('sharing')
      setError(null)
      
      const mediaStream = await navigator.mediaDevices.getDisplayMedia({
        video: {
          cursor: 'always',
          displaySurface: 'monitor'
        },
        audio: false,
      })

      setStream(mediaStream)
      
      if (videoRef.current) {
        videoRef.current.srcObject = mediaStream
      }

      // Set up stream ended handler
      const videoTrack = mediaStream.getVideoTracks()[0]
      videoTrack.onended = () => {
        stopScreenShare()
      }

      onStream?.(mediaStream)
      
      // Start auto-analysis if enabled
      if (isAutoAnalyzing) {
        startAutoAnalysis()
      }
      
      return mediaStream
    } catch (err) {
      console.error('Screen sharing error:', err)
      setState('error')
      setError('Failed to start screen sharing. Please try again.')
      toast({
        title: 'Screen Share Error',
        description: 'Failed to start screen sharing. Please check your permissions and try again.',
        variant: 'destructive'
      })
      return null
    }
  }, [isAutoAnalyzing, onStream, toast])

  // Stop screen sharing
  const stopScreenShare = useCallback(() => {
    if (stream) {
      stream.getTracks().forEach(track => track.stop())
      setStream(null)
    }
    
    if (videoRef.current) {
      videoRef.current.srcObject = null
    }
    
    stopAutoAnalysis()
    setState('idle')
  }, [stream])

  // Capture screenshot from stream
  const captureScreenshot = useCallback(() => {
    if (!videoRef.current || !canvasRef.current) return null
    
    const video = videoRef.current
    const canvas = canvasRef.current
    const context = canvas.getContext('2d')
    
    if (!context) return null
    
    // Set canvas dimensions to match video
    canvas.width = video.videoWidth
    canvas.height = video.videoHeight
    
    // Draw video frame to canvas
    context.drawImage(video, 0, 0, canvas.width, canvas.height)
    
    // Get image data URL
    const imageUrl = canvas.toDataURL('image/png')
    setCapturedImage(imageUrl)
    setState('captured')
    
    return imageUrl
  }, [])

  // Analyze the captured image
  const analyzeScreenshot = useCallback(async (imageUrl: string) => {
    if (!imageUrl) return null
    
    setState('analyzing')
    
    try {
      // Simulate analysis (replace with actual API call)
      await new Promise(resolve => setTimeout(resolve, 2000))
      
      const mockAnalysis = "This is a mock analysis of the screen capture. In a real implementation, this would be generated by an AI service."
      
      setAnalysis(mockAnalysis)
      onAnalysis?.(mockAnalysis)
      setState('completed')
      
      return mockAnalysis
    } catch (err) {
      console.error('Analysis error:', err)
      setState('error')
      setError('Failed to analyze screenshot')
      toast({
        title: 'Analysis Error',
        description: 'Failed to analyze the screenshot. Please try again.',
        variant: 'destructive'
      })
      return null
    }
  }, [onAnalysis, toast])

  // Start auto-analysis
  const startAutoAnalysis = useCallback(() => {
    if (analysisInterval.current) clearInterval(analysisInterval.current)
    
    analysisInterval.current = setInterval(() => {
      if (state === 'sharing') {
        const imageUrl = captureScreenshot()
        if (imageUrl) {
          analyzeScreenshot(imageUrl)
        }
      }
    }, 10000) // Analyze every 10 seconds
    
    setIsAutoAnalyzing(true)
  }, [captureScreenshot, analyzeScreenshot, state])

  // Stop auto-analysis
  const stopAutoAnalysis = useCallback(() => {
    if (analysisInterval.current) {
      clearInterval(analysisInterval.current)
      analysisInterval.current = null
    }
    setIsAutoAnalyzing(false)
  }, [])

  // Toggle auto-analysis
  const toggleAutoAnalysis = useCallback(() => {
    if (isAutoAnalyzing) {
      stopAutoAnalysis()
    } else {
      startAutoAnalysis()
    }
  }, [isAutoAnalyzing, startAutoAnalysis, stopAutoAnalysis])

  return {
    // State
    state,
    stream,
    capturedImage,
    analysis,
    isAutoAnalyzing,
    error,
    
    // Refs
    videoRef,
    canvasRef,
    
    // Actions
    startScreenShare,
    stopScreenShare,
    captureScreenshot,
    analyzeScreenshot,
    toggleAutoAnalysis,
    startAutoAnalysis,
    stopAutoAnalysis,
    
    // State helpers
    isSharing: state === 'sharing',
    isAnalyzing: state === 'analyzing',
    hasError: state === 'error',
    isCompleted: state === 'completed',
  }
}
